@using System.Globalization;
@using GBX.NET;
@using GBX.NET.Engines.Game;
@using System.Runtime.InteropServices.JavaScript;
@using MapViewerEngine.Modules;
@using MapViewerEngine.Shared;

@inherits ToolComponentBase<MapViewerEngineTool>
@implements IAsyncDisposable

@inject IJSRuntime JS
@inject IDynamicScriptService DynamicScript
@inject MapViewerEngineHubConnection HubConnection

<div class="container">
    <div class="rectangle info-panel">
        <div>FPS:</div>
        <div>@FPS</div>
        <div>Calls:</div>
        <div>@Calls</div>
        <div>Triangles:</div>
        <div>@Triangles</div>
        <div>Geometries:</div>
        <div>@Geometries</div>
        <div>Textures:</div>
        <div>@Textures</div>
    </div>

    @if (tool?.Map is not null)
    {
        <div class="map-name">
            <FormattedText Text="@tool.Map.MapName" />
            <div class="map-author">by <FormattedText Text="@(tool.Map.AuthorNickname ?? tool.Map.AuthorLogin)" /></div>
        </div>
    }

    @if (Exc is not null)
    {
        <div style="position: absolute;">@Exc</div>
    }

    <canvas></canvas>
</div>

@code {
    private Timer? timer;
    private MapViewerEngineTool? tool;

    private JSObject? renderer;

    public MapViewerEngineTool Tool => tool ?? throw new Exception();

    public string? Exc { get; set; }

    public int RefreshInterval { get; set; } = 500;
    public int FPS { get; private set; }
    public int Calls { get; private set; }
    public int Triangles { get; private set; }
    public int Geometries { get; private set; }
    public int Textures { get; private set; }

    protected override void OnInitialized()
    {
        timer = new Timer(TimerCallback, null, 0, RefreshInterval);

        var map = this.GbxSelection.FirstOrDefault()?.Object?.Node as CGameCtnChallenge;

        if (map is null)
        {
            return;
        }

        tool = new MapViewerEngineTool(map) { HubConnection = HubConnection };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        await JSHost.ImportAsync("three", "https://unpkg.com/three@0.149.0/build/three.min.js");
        await JSHost.ImportAsync(nameof(Renderer), "../_content/MapViewerEngine/js/renderer.js");
        await JSHost.ImportAsync(nameof(Cam), "../_content/MapViewerEngine/js/cam.js");
        await JSHost.ImportAsync(nameof(Solid), "../_content/MapViewerEngine/js/solid.js");
        await JSHost.ImportAsync(nameof(Shader), "../_content/MapViewerEngine/js/shader.js");

        renderer = Renderer.Create();
        Renderer.CreateScene();
        var cam = Cam.Create(distance: 256);

        Renderer.SpawnSampleObjects();

        Renderer.Animate();

        if (tool is null)
        {
            return;
        }

        Cam.Move(Tool.AbsoluteTrueMapCenter.X, 48, Tool.AbsoluteTrueMapCenter.Z);

        await Tool.LoadAsync();
    }

    private int? framesBefore;

    private void TimerCallback(object? state)
    {
        var info = renderer?.GetPropertyAsJSObject("info");

        if (info is null)
        {
            return;
        }

        var infoRender = info.GetPropertyAsJSObject("render");

        if (infoRender is not null)
        {
            var framesNow = infoRender.GetPropertyAsInt32("frame");

            FPS = (framesNow - framesBefore.GetValueOrDefault(framesNow)) * (1000 / RefreshInterval);

            framesBefore = framesNow;

            Calls = infoRender.GetPropertyAsInt32("calls");
            Triangles = infoRender.GetPropertyAsInt32("triangles");
        }

        var infoMemory = info.GetPropertyAsJSObject("memory");

        if (infoMemory is not null)
        {
            Geometries = infoMemory.GetPropertyAsInt32("geometries");
            Textures = infoMemory.GetPropertyAsInt32("textures");
        }

        StateHasChanged();
    }

    protected override async ValueTask DisposeAsync(bool disposing)
    {
        if (tool is not null)
        {
            tool.Dispose();
        }

        await HubConnection.StopAsync();
        
        timer?.Dispose();
        Renderer.Dispose();

        await base.DisposeAsync(disposing);
    }
}